# -*- coding: utf-8 -*-
"""Mobile Price Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i8H22FvftnsJL3EDf-JlndKA9Q2fLUmS

# Preparing Notebook

## Installing Dependencies
"""

!pip install pykan --quiet

"""## Importing Libraries"""

#Model Import & EDA
import os
import kagglehub
import pandas as pd
import numpy as np
#Visualizations
import seaborn as sns
import matplotlib.pyplot as plt
#Feature preprocessing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
#Model Building
import torch
from kan import *

"""## Downloading Dataset"""

path = kagglehub.dataset_download("iabhishekofficial/mobile-price-classification")

for files in os.listdir(path):
  if files.endswith('test.csv'):
    df_test = pd.read_csv(os.path.join(path, files))
  elif files.endswith('train.csv'):
    df_train = pd.read_csv(os.path.join(path, files))

"""# EDA"""

df_train.shape, df_test.shape

df_train.info()

df_test.info()

df_train.head()

sns.jointplot(x='ram',y='price_range',data=df_train,color='yellow',kind='kde');

sns.heatmap(df_train.drop(['price_range'], axis = 'columns').corr())

"""# Preprocessing"""

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(device)

"""## Feature Scaling"""

X = df_train.drop(['price_range'], axis = 'columns')
y = df_train['price_range']
X_unscaled = X[X.nunique().loc[X.nunique().values > 2].index.tolist()]
X_binary = X[X.nunique().loc[X.nunique().values <= 2].index.tolist()]

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_unscaled)

X = np.concatenate((X_scaled, X_binary), axis=1)

X_train,X_test,y_train,y_test = train_test_split(X, y, test_size = 0.1, stratify = y)

X_train.shape, y_test.shape

dataset = {
    'train_input': torch.tensor(X_train, dtype=torch.float32).to(device),
    'train_label': torch.tensor(y_train.values.reshape(-1, 1), dtype=torch.float32).to(device),
    'test_input': torch.tensor(X_test, dtype=torch.float32).to(device),
    'test_label': torch.tensor(y_test.values.reshape(-1, 1), dtype=torch.float32).to(device)
}

"""# Model Building"""

model = KAN(width=[20,8,4], grid=3,k=4,device=device)
# grid = granularity of splines, k = order of the basis functions(B-splines)
results = model.fit(dataset, opt= 'LBFGS', steps=25, lr=0.01, lamb_entropy=2.,)

"""## Plotting Visualizations

### Performance on Training and Testing Dataset
"""

plt.plot(results['train_loss'], label= 'Training Loss')
plt.plot(results['test_loss'], label= 'Testing Loss')
plt.xlabel('Steps')
plt.ylabel('Loss')
plt.legend()
plt.show()

"""### Model Structure"""

plt.figure(figsize=(10,20))
model.plot(beta=8)

"""### Symbolic Model Visualization"""

lib = ['x','x^2','x^3','x^4','exp','log','sqrt','tanh','sin','tan','abs']
model.auto_symbolic(lib=lib)

formula = model.symbolic_formula()[0][0]
ex_round(formula, 4)

"""## Model Evaluation"""

def accuracy_score(y_true, y_pred):
  y_true = y_true.cpu().numpy() if isinstance(y_true, torch.Tensor) else y_true
  y_pred = y_pred.cpu().numpy() if isinstance(y_pred, torch.Tensor) else y_pred

  correct_predictions = np.sum(y_true == y_pred)
  total_predictions = len(y_true)
  accuracy = correct_predictions / total_predictions

  return accuracy

def accuracy_score(y_true, y_pred):
    y_true = y_true.cpu().numpy() if isinstance(y_true, torch.Tensor) else np.array(y_true)
    y_pred = y_pred.cpu().numpy() if isinstance(y_pred, torch.Tensor) else np.array(y_pred)

    accuracy = np.mean(y_true == y_pred)
    return accuracy

"""# Model Testing"""

y_train_true = torch.argmax(model(dataset['train_input']), dim=1)
y_test_true = torch.argmax(model(dataset['test_input']), dim=1)

train_predictions = torch.argmax(model(dataset['train_input']), dim=1)
test_predictions = torch.argmax(model(dataset['test_input']), dim=1)

accuracy_score(y_train_true, train_predictions), accuracy_score(y_test_true, test_predictions)

df_test = df_test.drop(['id'], axis = 'columns')
X_test_unscaled = df_test[df_test.nunique().loc[df_test.nunique().values > 2].index.tolist()]
X_test_binary = df_test[df_test.nunique().loc[df_test.nunique().values <= 2].index.tolist()]

X_test_scaled = scaler.transform(X_test_unscaled)  # Use the same scaler fitted on training data
X_test_processed = np.concatenate((X_test_scaled, X_test_binary), axis=1)

X_test_tensor = torch.tensor(X_test_processed, dtype=torch.float32).to(device)

predictions = model(X_test_tensor)  # Or model.predict(X_test_tensor) if available
predicted_classes = torch.argmax(predictions, dim=1)

predicted_classes = predicted_classes.cpu().numpy()
predicted_classes